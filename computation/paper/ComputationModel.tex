\chapter{计算模型}
\section{图灵机}
\label{sec:TuringMachine}
图灵机$M$能够接受停机的所有输入信息串的集合就是$M$能识别的语言。       
\begin{equation*}
        L(M) = \{ \omega | q_0 \omega \vdash  xq_fy \}
\end{equation*}
如果有图灵机识别一个语言，则称该语言是图灵可识别的。又称为递归可枚举的。
如果有图灵机对所有输入都停机，则称图灵可判定。这样的语言称为图灵可判定的。简称可判定。

\paragraph{图灵机的组成}
\begin{itemize}
        \item 两端无限的线性带（读写介质）
        \item 有限的符号表（表示信息）
        \item 有限的信息处理状态
        \item 信息处理动作（静止，左、右移）
        \item 信息处理方法（规则）
\end{itemize}
\paragraph{图灵机的变形}
\begin{itemize}
        \item 多带图灵机
        \item 非确定图灵机
        \item 多指针图灵机
        \item 多维图灵机
        \item 离线图灵机
\end{itemize}
\paragraph{与图灵机等价的计算模型}
\begin{itemize}
        \item 寄存器机
        \item 波斯特系统
        \item 组合子系统
        \item 马尔可夫算法
\end{itemize}

\section{寄存器机}
在数理逻辑和理论计算机科学中，寄存器机（Register machine），
又译为暂存器机，是以类似于使用图灵机的方式使用的一类抽象机器。所有模型都是图灵等价的。

寄存器机得名于它有一个或多个``寄存器''替代了图灵机的磁带和磁头，
这个模型使用了多个唯一寻址的寄存器，每个都持有一个单一正整数。

在文献中至少可找到4个子类，下面按最原始到最类似计算机的次序列出：
\begin{itemize}
        \item 计数器机 最原始和精简的模型。
                缺乏间接寻址。指令在按照哈佛结构的有限状态机内。
        \item 指针机 计数器机和RAM模型的混合。
                比这两个模型更少共通更多抽象。指令在按照哈佛结构的有限状态机内。
        \item 随机存取机（RAM） 带有间接寻址和通常扩充的指令集。指令在按照哈佛结构的有限状态机内。
        \item 随机存取存储程序机（RASP） 带有指令在其寄存器中的RAM，类似于通用图灵机；
                因此它是冯·诺伊曼结构的一个例子。
                但是不同于计算机的是这个模型是带有有效无限个寄存器的“理想”机器。
                不像计算机甚至RISC计算机，指令集在指令数目上是非常精简的。
\end{itemize}

任何正确定义的寄存器机都是图灵等价的。计算速度严重依赖于模型细节。
寄存器机是一种与图灵机等价的，介于图灵机和实际数字计算机之间的一种抽象机。
用于分析算法效率和机器代码相关的研究。寄存器机的一般结构为：寄存器、指令集、
控制器、输入输出带和指令标号。典型的寄存器机有计数器机、指针机和RAM机以及RASP机。

\section{RAM机}
RAM（Random Access Machine）是一种为了分析算法性能而提出的近似于真实计算机的模型。
《算法导论》\cite{DBLP:books/daglib/0023376}对RAM机的描述是：
\begin{quotation}
        在RAM模型中，我们不试图去对现代计算机中很普遍的内存体系进行建模。
        即，我们不对缓存或虚拟内存进行建模。
        几个计算模型会尝试考虑内存体系的影响，这在实时计算机上的实时程序中有时很有意义。
        本书中有少量的问题会涉及内存体系的影响，但本书中的绝大部分分析将不会考虑它们。
        包含内存体系的模型要比RAM模型要复杂的多，因此它们可能较难处理。
        此外，在实际计算机中，RAM模型分析常常能对性能进行极好的预测。
\end{quotation}
所以，RAM机是一个比图灵机更贴近实际计算机，但是对实际计算机的许多方面都做了严格规定
的理想机器，它没有考虑如访问内存和磁盘的延时或者缓存的影响，而仅仅将访问一个地址的
内容规定为一个$O(1)$的操作。事实上，RAM机还对指令及其成本做了规定
\cite{DBLP:books/daglib/0023376}：
\begin{quotation}
        严格的说，我们需要精确的定义RAM模型的指令及其成本。
        但是这样做会比较单调，并且对算法设计和分析没有多大的深入。
        所以我们必须小心的不要滥用RAM模型。
        例如，如果RAM有一个进行排序的指令会怎么样？这时我们可以用一条指令进行排序。
        这样的RAM是不现实的，因为现实中的计算机没有这样的指令。
        因此，我们的方向是现实中的计算机是如何设计的。
        RAM模型的指令能够在现实中的计算机中普遍找到：
        算数（像加、减、乘、除、取余、向下取整、向上取整）、
        数据移动（加载、保存、复制）以及控制（条件和非条件分支、子程序的调用和返回）。
        每一个这样的指令要花费一个常量时间。
\end{quotation}
除了指令及其成本，RAM还规定，指令是串行执行的，没有任何并发操作\cite{DBLP:books/daglib/0023376}。
数据的类型为整数和浮点数，数据的每一个子的大小都有限制。
在RAM机器为模型的分析中，算法耗时的基本单位为步，每一步执行常量时间，这样估计出来的时间复杂度
能够独立于具体的硬件和操作系统，对现实也具有较好的指导意义。
